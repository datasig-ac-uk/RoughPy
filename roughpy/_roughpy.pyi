import enum
from abc import ABC, abstractmethod
from datetime import date, datetime, time
from fractions import Fraction
from typing import (Any, Callable, Dict, Final, Iterator, List, Optional,
                    Sequence, Tuple, Union, overload)

from numpy.typing import ArrayLike

class ScalarTypeMeta(type):
    ...


class ScalarTypeBase(metaclass=ScalarTypeMeta):
    ...


class SPReal(ScalarTypeBase):
    ...


class DPReal(ScalarTypeBase):
    ...


class Rational(ScalarTypeBase):
    ...


class HPReal(ScalarTypeBase): ...


class BFloat16(ScalarTypeBase): ...


class Scalar:

    def scalar_type(self) -> ScalarTypeMeta:
        ...

    def __neg__(self) -> Scalar: ...

    def __add__(self, other: Scalar) -> Scalar: ...

    def __sub__(self, other: Scalar) -> Scalar: ...

    def __mul__(self, other: Scalar) -> Scalar: ...

    def __div__(self, other: Scalar) -> Scalar: ...

    def __iadd__(self, other: Scalar) -> Scalar: ...

    def __isub__(self, other: Scalar) -> Scalar: ...

    def __imul__(self, other: Scalar) -> Scalar: ...

    def __idiv__(self, other: Scalar) -> Scalar: ...

    def __eq__(self, other: Scalar) -> bool: ...

    def __ne__(self, other: Scalar) -> bool: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...


ScalarLike = Union[Scalar, float, int, Fraction]


class Monomial:
    def __init__(self,
                 string: Union[
                     None, List[str], List[Tuple[str, int]], Dict[str, int]]
                 ):
        ...

    @overload
    def __init__(self, symbol: str, power: int): ...

    def degree(self) -> int: ...

    def __len__(self) -> int: ...

    def __getitem__(self, item: str) -> int: ...

    def __setitem__(self, key: str, value: int): ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __add__(self, other: Monomial) -> PolynomialScalar: ...

    def __sub__(self, other: Monomial) -> PolynomialScalar: ...

    def __mul__(self, other: Monomial) -> Monomial: ...

    @overload
    def __mul__(self, other: ScalarLike) -> PolynomialScalar: ...

    def __pow__(self, exponent: int, modulo=None) -> Monomial: ...

    def __pos__(self) -> PolynomialScalar: ...

    def __neg__(self) -> PolynomialScalar: ...

    def __bool__(self) -> bool: ...

    def __iadd__(self, other: Monomial) -> PolynomialScalar: ...

    def __isub__(self, other: Monomial) -> PolynomialScalar: ...

    def __imul__(self, other: Monomial) -> Monomial: ...

    @overload
    def __imul__(self, other: ScalarLike) -> PolynomialScalar: ...

    def __ipow__(self, other: int) -> Monomial: ...

    def __hash__(self): ...

    def __eq__(self, other: Monomial) -> bool: ...

    def __ne__(self, other: Monomial) -> bool: ...

    def __le__(self, other: Monomial) -> bool: ...

    def __lt__(self, other: Monomial) -> bool: ...

    def __ge__(self, other: Monomial) -> bool: ...

    def __gt__(self, other: Monomial) -> bool: ...


class PolynomialScalar:

    def __init__(self, monomial: Monomial): ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __len__(self) -> int: ...

    def __getitem__(self, item: Monomial) -> ScalarLike: ...

    def __setitem__(self, item: Monomial, value: ScalarLike): ...

    def degree(self) -> int: ...

    def __pos__(self) -> PolynomialScalar: ...

    def __neg__(self) -> PolynomialScalar: ...

    def __bool__(self): ...

    def __add__(self, other: Union[ScalarLike, Monomial]) -> PolynomialScalar:
        ...

    def __sub__(self, other: Union[ScalarLike, Monomial]) -> PolynomialScalar:
        ...

    def __mul__(self, other: Union[ScalarLike, Monomial]) -> PolynomialScalar:
        ...

    def __truediv__(self, other: Union[int, float, Fraction]) -> \
            PolynomialScalar: ...

    def __pow__(self, power: int, modulo=None) -> PolynomialScalar: ...

    def __iadd__(self, other: Union[ScalarLike, Monomial]) -> \
            PolynomialScalar: ...

    def __isub__(self, other: Union[ScalarLike, Monomial]) -> \
            PolynomialScalar: ...

    def __imul__(self, other: Union[ScalarLike, Monomial]) -> \
            PolynomialScalar: ...

    def __idiv__(self, other: Union[int, float, Fraction]) -> \
            PolynomialScalar: ...

    def __eq__(self, other: PolynomialScalar) -> bool: ...

    def __ne__(self, other: PolynomialScalar) -> bool: ...


class IntervalType(enum.Enum):
    Clopen = ...
    # Opencl = ...   # Currently disabled until support is added in the
    # underlying library


class Interval(ABC):
    interval_type: IntervalType = ...

    @abstractmethod
    def inf(self) -> float: ...

    @abstractmethod
    def sup(self) -> float: ...

    def included_end(self) -> float: ...

    def excluded_end(self) -> float: ...

    def intersects_with(self, other: Interval) -> bool: ...

    def contains(self, other: Union[float, Interval]) -> bool: ...

    def __eq__(self, other: Interval) -> bool: ...

    def __ne__(self, other: Interval) -> bool: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...


class RealInterval(Interval):

    def inf(self) -> float: ...

    def sup(self) -> float: ...


class Dyadic:
    k: Final[int] = ...
    n: Final[int] = ...

    @staticmethod
    def dyadic_equals(lhs: Dyadic, rhs: Dyadic) -> bool: ...

    @staticmethod
    def rational_equals(lhs: Dyadic, rhs: Dyadic) -> bool: ...

    def rebase(self, resolution: int): ...

    def __float__(self) -> float: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __lt__(self, other: Dyadic) -> bool: ...

    def __le__(self, other: Dyadic) -> bool: ...

    def __gt__(self, other: Dyadic) -> bool: ...

    def __ge__(self, other: Dyadic) -> bool: ...

    def __iadd__(self, other: int): ...


class DyadicInterval(Interval, Dyadic):
    def inf(self) -> float: ...

    def sup(self) -> float: ...

    def dyadic_included_end(self) -> Dyadic: ...

    def dyadic_excluded_end(self) -> Dyadic: ...

    def dyadic_inf(self) -> Dyadic: ...

    def dyadic_sup(self) -> Dyadic: ...

    def shrink_to_contained_end(self, arg: int = ...): ...

    def shrink_to_omitted_end(self): ...

    def shrink_left(self): ...

    def shrink_right(self): ...

    @staticmethod
    def to_dyadic_intervals(interval: Interval,
                            resolution: int,
                            interval_type: IntervalType) -> Sequence[
        Interval]: ...

    @overload
    @staticmethod
    def to_dyadic_intervals(inf: float,
                            sup: float,
                            resolution: int,
                            interval_type: IntervalType) -> Sequence[
        Interval]: ...


DateTimeLike = Union[datetime, date, time]


class DateTimeInterval(Interval):
    def __init__(self, begin: DateTimeLike, end: DateTimeLike): ...

    def inf(self) -> float: ...

    def sup(self) -> float: ...


class Partition(Interval):
    def inf(self) -> float: ...

    def sup(self) -> float: ...

    def __len__(self) -> int: ...

    def __getitem__(self, index: int) -> RealInterval: ...

    def __str__(self) -> str: ...

    def refine_midpoints(self) -> Partition: ...

    def mesh(self) -> float: ...

    def intermediates(self) -> List[float]: ...

    def insert_intermediate(self, new_intermediate: float): ...

    def merge(self, other: Partition) -> Partition: ...


IntervalPredicate = Callable[[Interval], bool]


def segment(interval: Interval, predicate: IntervalPredicate,
            max_depth: int) -> List[RealInterval]: ...


class VectorType(enum.Enum):
    DenseVector = ...
    SparseVector = ...


class TensorKey:
    width: Final[int] = ...
    max_degree: Final[int] = ...

    def degree(self) -> int: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, other: TensorKey): ...


class LieKey:
    def __str__(self) -> str: ...


class TensorKeyIterator:

    def __next__(self) -> TensorKey: ...


class LieKeyIterator:

    def __next__(self) -> LieKey: ...


class TensorBasis:
    width: Final[int]
    depth: Final[int]
    dimension: Final[int]

    def index_to_key(self, index: int) -> TensorKey: ...

    def key_to_index(self, key: TensorKey) -> int: ...

    def size(self, degree: int) -> int: ...


class LieBasis:
    width: Final[int]
    depth: Final[int]
    dimension: Final[int]

    def index_to_key(self, index: int) -> TensorKey: ...

    def key_to_index(self, key: TensorKey) -> int: ...

    def size(self, degree: int) -> int: ...


class Context:
    width: Final[int]
    depth: Final[int]
    ctype: Final[ScalarTypeMeta]
    lie_basis: Final[LieBasis]
    tensor_basis: Final[TensorBasis]

    def lie_size(self, degree: int) -> int: ...

    def tensor_size(self, degree: int) -> int: ...

    def cbh(self, lies: Sequence[Lie], vec_type: Optional[VectorType] = None) \
            -> Lie: ...

    def compute_signature(self, data: Any, **kwargs: Any) -> FreeTensor: ...

    def to_logsignature(self, signature: FreeTensor) -> Lie: ...

    def lie_to_tensor(self, lie: Lie) -> FreeTensor: ...

    def tensor_to_lie(self, tensor: FreeTensor) -> Lie: ...

    def zero_lie(self, *args: Any, **kwargs: Any) -> Lie: ...

    def __enter__(self): ...

    def __exit__(self, exc_type, exc_val, exc_tb): ...


def get_context(width: int,
                depth: int,
                coeffs: Union[None, str, type, ScalarTypeMeta] = ...
                ) -> Context: ...


class LieIteratorItem:

    def key(self) -> LieKey: ...

    def value(self) -> Scalar: ...


class FreeTensorIteratorItem:

    def key(self) -> TensorKey: ...

    def value(self) -> Scalar: ...


class ShuffleTensorIteratorItem:

    def key(self) -> TensorKey: ...

    def value(self) -> Scalar: ...


class Lie:
    width: Final[int] = ...
    max_degree: Final[int] = ...
    dtype: Final[ScalarTypeMeta] = ...
    storage_type: Final[VectorType] = ...

    def size(self) -> int: ...

    def dimension(self) -> int: ...

    def degree(self) -> int: ...

    def __iter__(self) -> Iterator[LieIteratorItem]: ...

    def __neg__(self) -> Lie: ...

    def __add__(self, other: Lie) -> Lie: ...

    def __sub__(self, other: Lie) -> Lie: ...

    def __mul__(self, other: ScalarLike) -> Lie: ...

    def __rmul__(self, other: ScalarLike) -> Lie: ...

    def __truediv__(self, other: ScalarLike) -> Lie: ...

    @overload
    def __mul__(self, other: Lie) -> Lie: ...

    def __iadd__(self, other: Lie): ...

    def __isub__(self, other: Lie): ...

    def __imul__(self, other: ScalarLike): ...

    def __itruediv__(self, other: ScalarLike): ...

    @overload
    def __imul__(self, other: Lie): ...

    def add_scal_mul(self, other: Lie, scalar: ScalarLike): ...

    def sub_scal_mul(self, other: Lie, scalar: ScalarLike): ...

    def add_scal_div(self, other: Lie, scalar: ScalarLike): ...

    def sub_scal_div(self, other: Lie, scalar: ScalarLike): ...

    def add_mul(self, lhs: Lie, rhs: Lie): ...

    def sub_mul(self, lhs: Lie, rhs: Lie): ...

    def mul_smul(self, other: Lie, scalar: ScalarLike): ...

    def mul_sdiv(self, other: Lie, scalar: ScalarLike): ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, other: Lie) -> bool: ...

    def __ne__(self, other: Lie) -> bool: ...

    def __getitem__(self, item: LieKey) -> Scalar: ...


class FreeTensor:
    width: Final[int] = ...
    max_degree: Final[int] = ...
    dtype: Final[ScalarTypeMeta] = ...
    storage_type: Final[VectorType] = ...

    def size(self) -> int: ...

    def dimension(self) -> int: ...

    def degree(self) -> int: ...

    def __iter__(self) -> Iterator[FreeTensorIteratorItem]: ...

    def __neg__(self) -> FreeTensor: ...

    def __add__(self, other: FreeTensor) -> FreeTensor: ...

    def __sub__(self, other: FreeTensor) -> FreeTensor: ...

    def __mul__(self, other: ScalarLike) -> FreeTensor: ...

    def __rmul__(self, other: ScalarLike) -> FreeTensor: ...

    def __truediv__(self, other: ScalarLike) -> FreeTensor: ...

    @overload
    def __mul__(self, other: FreeTensor) -> FreeTensor: ...

    def __iadd__(self, other: FreeTensor): ...

    def __isub__(self, other: FreeTensor): ...

    def __imul__(self, other: ScalarLike): ...

    def __itruediv__(self, other: ScalarLike): ...

    @overload
    def __imul__(self, other: FreeTensor): ...

    def add_scal_mul(self, other: FreeTensor, scalar: ScalarLike): ...

    def sub_scal_mul(self, other: FreeTensor, scalar: ScalarLike): ...

    def add_scal_div(self, other: FreeTensor, scalar: ScalarLike): ...

    def sub_scal_div(self, other: FreeTensor, scalar: ScalarLike): ...

    def add_mul(self, lhs: FreeTensor, rhs: FreeTensor): ...

    def sub_mul(self, lhs: FreeTensor, rhs: FreeTensor): ...

    def mul_smul(self, other: FreeTensor, scalar: ScalarLike): ...

    def mul_sdiv(self, other: FreeTensor, scalar: ScalarLike): ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, other: FreeTensor) -> bool: ...

    def __ne__(self, other: FreeTensor) -> bool: ...

    def __getitem__(self, item: TensorKey) -> Scalar: ...

    def exp(self) -> FreeTensor: ...

    def log(self) -> FreeTensor: ...

    def antipode(self) -> FreeTensor: ...


class ShuffleTensor:
    width: Final[int] = ...
    max_degree: Final[int] = ...
    dtype: Final[ScalarTypeMeta] = ...
    storage_type: Final[VectorType] = ...

    def size(self) -> int: ...

    def dimension(self) -> int: ...

    def degree(self) -> int: ...

    def __iter__(self) -> Iterator[ShuffleTensorIteratorItem]: ...

    def __neg__(self) -> ShuffleTensor: ...

    def __add__(self, other: ShuffleTensor) -> ShuffleTensor: ...

    def __sub__(self, other: ShuffleTensor) -> ShuffleTensor: ...

    def __mul__(self, other: ScalarLike) -> ShuffleTensor: ...

    def __rmul__(self, other: ScalarLike) -> ShuffleTensor: ...

    def __truediv__(self, other: ScalarLike) -> ShuffleTensor: ...

    @overload
    def __mul__(self, other: ShuffleTensor) -> ShuffleTensor: ...

    def __iadd__(self, other: ShuffleTensor): ...

    def __isub__(self, other: ShuffleTensor): ...

    def __imul__(self, other: ScalarLike): ...

    def __itruediv__(self, other: ScalarLike): ...

    @overload
    def __imul__(self, other: ShuffleTensor): ...

    def add_scal_mul(self, other: ShuffleTensor, scalar: ScalarLike): ...

    def sub_scal_mul(self, other: ShuffleTensor, scalar: ScalarLike): ...

    def add_scal_div(self, other: ShuffleTensor, scalar: ScalarLike): ...

    def sub_scal_div(self, other: ShuffleTensor, scalar: ScalarLike): ...

    def add_mul(self, lhs: ShuffleTensor, rhs: ShuffleTensor): ...

    def sub_mul(self, lhs: ShuffleTensor, rhs: ShuffleTensor): ...

    def mul_smul(self, other: ShuffleTensor, scalar: ScalarLike): ...

    def mul_sdiv(self, other: ShuffleTensor, scalar: ScalarLike): ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, other: ShuffleTensor) -> bool: ...

    def __ne__(self, other: ShuffleTensor) -> bool: ...

    def __getitem__(self, item: TensorKey) -> Scalar: ...


class Stream:
    width: Final[int]
    dtype: Final[ScalarTypeMeta]
    ctx: Final[Context]
    support: [RealInterval]

    def __repr__(self): ...

    def __str__(self): ...

    def restrict(self, interval: Interval) -> Stream: ...

    def simplify(self,
                 partition: Partition,
                 resolution: Optional[int]=None,
                 ctx: Optional[Context]=None,
                 depth: Optional[int]=None
                 ) -> Stream: ...

    def log_signature(self,
                      interval: Interval,
                      resolution: Union[int, float, None] = None,
                      *,
                      context: Optional[Context] = None,
                      depth: Optional[int] = None,
                      dtype: Optional[ScalarTypeMeta] = None
                      ) -> Lie: ...

    @overload
    def log_signature(self,
                      inf: float,
                      sup: float,
                      resolution: Union[int, float, None],
                      *,
                      context: Optional[Context],
                      depth: Optional[int] = None,
                      dtype: Optional[ScalarTypeMeta] = None
                      ) -> Lie: ...

    def signature(self,
                      interval: Interval,
                      resolution: Union[int, float, None] = None,
                      *,
                      context: Optional[Context] = None,
                      depth: Optional[int] = None,
                      dtype: Optional[ScalarTypeMeta] = None
                      ) -> FreeTensor: ...

    @overload
    def signature(self,
                      inf: float,
                      sup: float,
                      resolution: Union[int, float, None],
                      *,
                      context: Optional[Context],
                      depth: Optional[int] = None,
                      dtype: Optional[ScalarTypeMeta] = None
                      ) -> FreeTensor: ...


    def signature_derivative(self,
                             interval: Interval,
                             perturbation: Lie,
                             resolution: Optional[int]=None,
                             depth: Optional[int]=None
                             ) -> FreeTensor: ...

    @overload
    def signature_derivative(self,
                             perturbations: List[Tuple[Interval, Lie]],
                             resolution: Optional[int]=None,
                             depth: Optional[int]=None
                             ) -> FreeTensor: ...

class LieIncrementStream:

    @staticmethod
    def from_increments(increments: ArrayLike, **kwargs: Any) -> Stream:
        ...


class FunctionStream:

    @staticmethod
    def from_function(function: Callable[[float], ArrayLike]) -> Stream:
        ...


class PiecewiseAbelianStream:

    @staticmethod
    def construct(lies: List[(RealInterval, Lie)], **kwargs: Any) -> Stream: ...



class ExternalDataStream:

    @staticmethod
    def from_uri(uri: str, **kwargs: Any) -> Stream: ...


class BrownianStream:

    @staticmethod
    def with_generator(generator: str, **kwargs: Any) -> Stream: ...



class TickStream:
    @staticmethod
    def from_data(data: Any, **kwargs: Any): ...


class StreamSchema:

    @staticmethod
    def from_data(data: Union[
        Dict[float, Union[str, float, int]], Sequence[tuple]]) -> StreamSchema:
        ...

    @staticmethod
    def parse(
            schema: List[Dict[str, Union[str, List[str]]]]) -> StreamSchema: ...

    def get_labels(self) -> list[str]: ...


class TickStreamConstructionHelper:

    def __init__(self): ...

    @overload
    def __init__(self, schema_only: bool): ...

    @overload
    def __init__(self, schema: StreamSchema, schema_only: bool): ...
